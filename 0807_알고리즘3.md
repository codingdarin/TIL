## 부분집합 합 문제 정리

### 1. 완전검색 (Brute Force)
- 모든 가능한 부분집합을 생성하여 각각의 합을 계산
- 시간복잡도: O(2^n × n)

### 2. 부분집합 생성 방법

**기본 개념:**
- n개 원소 → 2^n개의 부분집합 (공집합 포함)
- 각 원소마다 포함/미포함 2가지 선택

**비트 표현:**
```python
arr = [1, 2, 3]
# 000 = [] (공집합)
# 001 = [3]
# 010 = [2] 
# 011 = [2, 3]
# 100 = [1]
# 101 = [1, 3]
# 110 = [1, 2]
# 111 = [1, 2, 3]
```

### 3. 구현 방법들

**방법 1: 중첩 반복문 (고정 길이)**
```python
arr = [1, 3, 5, 7]
bit = [0, 0, 0, 0]

def print_subset(bit):
    for i in range(4):
        if bit[i]:
            print(arr[i], end=' ')
    print()

for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print_subset(bit)
```

**방법 2: 비트 연산 (가변 길이)**
```python
arr = [1, 3, 5, 7]
n = len(arr)

for i in range(1 << n):  # 2^n만큼 반복
    subset = []
    for j in range(n):
        if i & (1 << j):  # j번째 비트가 1인지 확인
            subset.append(arr[j])
    print(subset)
```

**방법 3: 재귀 (백트래킹)**
```python
arr = [1, 3, 5, 7]
subset = []

def generate_subset(idx):
    if idx == len(arr):
        print(subset[:])  # 복사본 출력
        return
    
    # 포함하지 않는 경우
    generate_subset(idx + 1)
    
    # 포함하는 경우
    subset.append(arr[idx])
    generate_subset(idx + 1)
    subset.pop()

generate_subset(0)
```

### 4. 부분집합 합 문제 해결
```python
def subset_sum(arr, target):
    n = len(arr)
    
    for i in range(1 << n):
        current_sum = 0
        for j in range(n):
            if i & (1 << j):
                current_sum += arr[j]
        
        if current_sum == target:
            return True
    return False

# 사용 예
arr = [1, 3, 5, 7]
target = 8
print(subset_sum(arr, target))  # True (1+7=8 또는 3+5=8)
```

### 핵심 포인트
- 비트 연산이 가장 효율적이고 간결함
- `1 << n`은 2^n과 같음
- `i & (1 << j)`는 i의 j번째 비트 확인
- 실제 문제에서는 가지치기나 DP로 최적화 필요

---

### 비트 연산자
- **&**: 비트 단위 AND 연산 (둘 다 1일 때만 1)
- **|**: 비트 단위 OR 연산 (하나라도 1이면 1)  
- **<<**: 비트를 왼쪽으로 이동 (n << k = n × 2^k)
- **>>**: 비트를 오른쪽으로 이동 (n >> k = n ÷ 2^k)

### 비트 연산 활용법
- **1 << n**: 2^n 계산, 원소 n개일 때 부분집합 개수
- **i & (1 << j)**: i의 j번째 비트가 1인지 검사하는 마스킹 기법

### 부분집합 생성 (비트 활용)
```python
def generate_subsets(arr):
    n = len(arr)
    for i in range(1 << n):  # 2^n개 반복
        subset = []
        for j in range(n):
            if i & (1 << j):  # j번째 비트 확인
                subset.append(arr[j])
        print(subset)
```

## 검색과 정렬

### 순차 검색
- 배열의 첫 번째 원소부터 순서대로 탐색
- 정렬되지 않은 데이터에서 사용
- 시간복잡도: O(n)

### 이진 검색
- **전제조건**: 정렬된 배열
- **방법**: 중앙값과 비교하여 반씩 범위 축소
- **시간복잡도**: O(log n)
- **과정**: 전체 → 반 → 반의 반 → ... (1개 남을 때까지)

### 이진 검색 알고리즘
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### 핵심 개념
- 검색 알고리즘은 데이터 정렬 여부에 따라 선택
- 이진 검색의 재귀적 특성: 계속해서 반으로 나누어 탐색


## 선택 정렬 (Selection Sort)

### 기본 개념
- 가장 작은 값을 선택해서 앞쪽부터 차례로 배치
- 매 단계마다 미정렬 구간에서 최솟값을 찾아 현재 위치와 교환

### 알고리즘 과정
1. 전체 배열에서 최솟값 찾기
2. 첫 번째 위치와 교환
3. 나머지 배열에서 최솟값 찾기
4. 두 번째 위치와 교환
5. 배열이 정렬될 때까지 반복

### 코드 구현
```python
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n-1):  # 마지막 원소는 자동 정렬
        min_idx = i
        
        # 미정렬 구간에서 최솟값 찾기
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 최솟값과 현재 위치 교환
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```

### 시간복잡도
- 비교 연산: (n-1) + (n-2) + ... + 1 = n(n-1)/2
- 모든 경우에서 O(n²) - 최선, 평균, 최악 동일

### 공간복잡도
- O(1) - 제자리 정렬로 추가 메모리 불필요

### 특징
- **교환 횟수 적음**: 최대 n-1번만 교환
- **불안정 정렬**: 같은 값의 상대적 순서가 바뀔 수 있음
- **제자리 정렬**: 추가 배열 공간 불필요

### 장점
- 구현이 간단하고 직관적
- 메모리 사용량이 적음
- 교환 연산이 적어서 교환 비용이 클 때 유리

### 단점
- O(n²) 시간복잡도로 대용량 데이터에 비효율적
- 이미 정렬된 배열도 동일한 시간 소요
- 안정 정렬이 아님

### 버블 정렬과의 차이점
- 선택 정렬: 최솟값 찾은 후 한 번에 교환
- 버블 정렬: 인접 원소끼리 즉시 교환
- 선택 정렬이 교환 횟수 더 적음


