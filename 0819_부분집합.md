# 부분집합과 순열 - 백트래킹 기초

## 1. 부분집합 (Subset)

### 개념
- 집합의 부분집합: 원래 집합에서 0개 이상의 원소를 선택하여 만든 집합
- {1, 2}의 부분집합: {}, {1}, {2}, {1, 2} (총 2^n개)

### 손으로 해보기 - 단계별 과정
```
집합 {1, 2}에서 부분집합 만들기:

시작: []

1단계: 원소 1을 고려
- 포함 안함: []
- 포함함: [1]

2단계: 원소 2를 고려
- [] + 2 고려 → [] 또는 [2]
- [1] + 2 고려 → [1] 또는 [1,2]

최종 결과: [], [2], [1], [1,2]
```

### 재귀 구현
```python
def subset_simple(arr, index, current):
    # 기저 조건: 모든 원소를 다 고려했으면
    if index == len(arr):
        print(current)
        return
    
    # 선택 1: 현재 원소를 포함하지 않기
    subset_simple(arr, index + 1, current)
    
    # 선택 2: 현재 원소를 포함하기
    subset_simple(arr, index + 1, current + [arr[index]])

# 실행
arr = [1, 2]
subset_simple(arr, 0, [])
```

### 실행 과정 트리
```
subset_simple([1,2], 0, [])
├── subset_simple([1,2], 1, [])      # 1 포함 X
│   ├── subset_simple([1,2], 2, [])      # 2 포함 X → 출력: []
│   └── subset_simple([1,2], 2, [2])     # 2 포함 O → 출력: [2]
└── subset_simple([1,2], 1, [1])     # 1 포함 O
    ├── subset_simple([1,2], 2, [1])     # 2 포함 X → 출력: [1]
    └── subset_simple([1,2], 2, [1,2])   # 2 포함 O → 출력: [1,2]
```

## 2. 순열 (Permutation)

### 개념
- 순열: n개의 원소를 모두 사용하여 일렬로 나열하는 방법
- [1, 2, 3]의 순열: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] (총 n!개)

### 구현 방법

#### 방법 1: visited 배열 사용
```python
def permutation_visited(arr, current, visited):
    # 기저 조건: 모든 원소를 다 선택했으면
    if len(current) == len(arr):
        print(current)
        return
    
    # 각 원소에 대해 시도
    for i in range(len(arr)):
        if not visited[i]:  # 아직 사용하지 않은 원소라면
            visited[i] = True
            current.append(arr[i])
            permutation_visited(arr, current, visited)
            # 백트래킹
            current.pop()
            visited[i] = False

# 실행
arr = [1, 2, 3]
visited = [False] * len(arr)
permutation_visited(arr, [], visited)
```

#### 방법 2: 자리바꾸기 (Swap)
```python
def permutation_swap(arr, start):
    # 기저 조건: 모든 자리가 확정되면
    if start == len(arr):
        print(arr[:])  # 복사본 출력
        return
    
    # start 위치에 올 수 있는 모든 원소 시도
    for i in range(start, len(arr)):
        # 자리바꾸기
        arr[start], arr[i] = arr[i], arr[start]
        permutation_swap(arr, start + 1)
        # 원상복구
        arr[start], arr[i] = arr[i], arr[start]

# 실행
arr = [1, 2, 3]
permutation_swap(arr, 0)
```

### 두 방법의 차이점
- **visited 방법**: 원본 배열을 보존, 메모리 사용량 많음
- **swap 방법**: 원본 배열을 직접 수정, 메모리 효율적, 더 빠름

## 3. 백트래킹의 핵심 패턴
```
1. 선택하기 (Choose)
2. 재귀 호출 (Explore) 
3. 되돌리기 (Unchoose)
```

### 가지치기 (Pruning)
- 조건에 맞지 않는 경우 더 이상 진행하지 않고 되돌아감
- 시간 복잡도를 크게 줄일 수 있음

```python
# 예시: 합이 target을 초과하면 가지치기
def subset_with_sum(arr, index, current, current_sum, target):
    if current_sum > target:  # 가지치기
        return
    
    if index == len(arr):
        if current_sum == target:
            print(current)
        return
    
    # 포함하지 않기
    subset_with_sum(arr, index + 1, current, current_sum, target)
    
    # 포함하기
    subset_with_sum(arr, index + 1, current + [arr[index]], 
                   current_sum + arr[index], target)
```