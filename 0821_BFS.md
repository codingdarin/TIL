# BFS (너비 우선 탐색) 학습 정리

## BFS란?
- **너비 우선 탐색(Breadth-First Search)**
- 탐색 시작점의 인접 정점(노드)을 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
- 인접한 정점들에 대해 탐색을 한 후 차례로 다시 너비 우선 탐색을 진행해야 하므로 선입선출 형태의 자료구조인 큐를 활용
- 가까운 노드부터 차례대로 탐색하는 방법
- 물결이 퍼져나가듯이 탐색
- 현재 레벨의 모든 노드를 방문한 후 다음 레벨로 이동

## DFS와의 차이점
| 구분 | BFS | DFS |
|------|-----|-----|
| 탐색 방식 | 레벨별로 넓게 | 한 방향으로 깊게 |
| 사용 자료구조 | 큐 (Queue) | 스택 (Stack) |
| 특징 | FIFO (먼저 들어간 것이 먼저 나옴) | LIFO (나중에 들어간 것이 먼저 나옴) |

## 왜 큐를 사용하는가?
- **FIFO 특성**이 BFS의 레벨별 탐색과 완벽하게 일치
- 거리 1인 노드들을 먼저 처리한 후, 거리 2인 노드들을 처리
- 가까운 노드부터 순서대로 탐색 보장

### 큐 vs 스택 비교 예시
```
그래프: 1-2, 1-3, 2-4, 3-5, 3-6

BFS (큐): 1 → 2 → 3 → 4 → 5 → 6 (레벨별)
DFS (스택): 1 → 3 → 6 → 5 → 2 → 4 (깊이 우선)
```

## BFS 활용 분야
- **최단거리 찾기** (가중치가 없는 그래프)
- **레벨별 처리** (같은 깊이의 노드들)
- **연결성 확인** (두 노드가 연결되어 있는지)

## 시간복잡도
- **O(V + E)**
- V: 정점 수, E: 간선 수
- 모든 정점을 한 번씩 방문, 모든 간선을 한 번씩 확인

## 파이썬 구현

### 자료구조 선택
```python
from collections import deque

# 리스트 vs deque
리스트: append() O(1), pop(0) O(n) ❌
deque: append() O(1), popleft() O(1) ✅
```

### 기본 템플릿
```python
from collections import deque

def bfs(graph, start, n):
    distance = [0] * (n + 1)  # 거리 정보 저장 (0이면 미방문)
    queue = deque([start])
    distance[start] = 1       # 시작점 거리는 1로 설정
    
    while queue:
        current = queue.popleft()  # 큐에서 꺼냄
        print(current)             # 방문 처리
        
        for neighbor in graph[current]:
            if distance[neighbor] == 0:  # 미방문 노드
                distance[neighbor] = distance[current] + 1
                queue.append(neighbor)  # 큐에 넣음
```

## 방문 체크 최적화

### 큐에서 꺼낼 때 체크 (비효율적)
```python
# 같은 노드가 큐에 여러 번 들어갈 수 있음
while queue:
    node = queue.popleft()
    if not visited[node]:  # 꺼낼 때 체크
        visited[node] = True
```

### 큐에 넣을 때 체크 (효율적) ✅
```python
# 각 노드가 큐에 최대 1번만 들어감
for neighbor in graph[current]:
    if not visited[neighbor]:
        visited[neighbor] = True  # 넣을 때 바로 체크
        queue.append(neighbor)
```

## 거리 배열 활용법
```python
distance = [0] * (n + 1)  # 0이면 미방문, 양수면 거리
```

**장점:**
- 방문 체크와 거리 계산을 동시에 수행
- 하나의 패턴으로 다양한 문제 해결 가능

**활용:**
- 방문 여부: `distance[i] > 0`
- 실제 거리: `distance[i] - 1`
- 도달 불가능: `distance[i] == 0`

## 그래프 유형별 처리

### 방향 그래프
- 갈 수 있는 방향만 탐색
- 모든 노드에 도달하지 못할 수 있음

### 연결되지 않은 그래프
```python
def bfs_all(graph, n):
    visited = [False] * (n + 1)
    
    for start_node in range(1, n + 1):
        if not visited[start_node]:
            bfs(graph, start_node, visited)  # 각 컴포넌트별로 BFS
```

## 간선 입력 형식 이해
```
입력: 4 2 1 2 1 3 5 2 4 6 5 6 6 7 3 7

해석: 연결된 정점 쌍들을 일렬로 나열
(4,2) (1,2) (1,3) (5,2) (4,6) (5,6) (6,7) (3,7)
```

### 인접리스트 구성
```python
for i in range(E):
    v1, v2 = arr[i*2], arr[i*2+1]  # 2개씩 묶어서 읽기
    adj_list[v1].append(v2)  # 양방향 그래프
    adj_list[v2].append(v1)  # 서로 연결
```

## 핵심 포인트
- **거리 배열 패턴**에 익숙해지기 (방문 체크 + 거리 계산)
- **큐에 넣을 때 방문 체크**하여 중복 방지
- **deque 사용**으로 성능 최적화
- **간선 입력 형식** 정확히 이해하기
