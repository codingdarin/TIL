# 트리 기초 개념 정리

## 1. 트리의 정의

### 수학적 정의
- **연결되어 있고 사이클이 없는 그래프**
- 연결성: 모든 노드가 어떤 경로로든 연결됨
- 비순환성: 어떤 노드에서 시작해도 같은 노드로 돌아오는 경로가 없음

### 동등한 정의들
- n개의 노드를 가지고 정확히 n-1개의 간선을 가진 연결된 그래프
- 임의의 두 노드 사이에 정확히 하나의 경로만 존재하는 그래프
- 연결되어 있으면서 간선 하나를 제거하면 연결이 끊어지는 그래프
- 사이클이 없으면서 간선 하나를 추가하면 사이클이 생기는 그래프

### 그래프와의 관계
- **모든 트리는 그래프이다** (O)
- **모든 그래프가 트리는 아니다** (X)
- 트리는 그래프의 특수한 형태

## 2. 트리의 기본 용어

### 구조 관련 용어
- **루트(Root)**: 가장 위에 있는 노드, 트리의 시작점
- **노드(Node)**: 트리의 각 요소
- **간선(Edge)**: 노드들을 연결하는 선
- **부모-자식 관계**: 상위 노드가 부모, 하위 노드가 자식
- **리프(Leaf)**: 자식이 없는 노드들

### 차수와 레벨
- **차수(Degree)**: 노드가 가진 자식 노드의 개수
  - 노드의 차수: 그 노드의 자식 개수
  - 트리의 차수: 트리에서 가장 큰 차수
- **레벨(Level)**: 루트부터의 거리 (레벨 0부터 시작)
  - 루트의 레벨: 0
  - 다른 노드의 레벨: 부모의 레벨 + 1
- **높이/깊이(Height/Depth)**: 트리의 가장 깊은 레벨

## 3. 이진트리 (Binary Tree)

### 정의
- **각 노드의 차수가 최대 2인 트리**
- 모든 노드가 자식을 0개, 1개, 또는 2개만 가질 수 있음

### 주요 특징
- **순서가 중요**: 왼쪽 자식 vs 오른쪽 자식을 구분
- **자식이 1개여도 위치 지정**: 왼쪽 자식인지 오른쪽 자식인지 명확히 구분

### 이진트리의 성질 (레벨 0부터 시작)
- **레벨 k의 최대 노드 수**: 2^k
- **높이 h인 이진트리의 최대 노드 수**: 2^(h+1) - 1
- **n개 노드를 가진 이진트리의 최소 높이**: ⌊log₂n⌋

## 4. 이진트리의 종류

### 포화 이진트리 (Full/Perfect Binary Tree)
- 모든 레벨이 완전히 채워진 트리
- 모든 리프 노드가 같은 레벨에 위치
- 노드 수가 정확히 2^(h+1) - 1개
- 내부 노드 수: 2^h - 1개, 리프 노드 수: 2^h개

### 완전 이진트리 (Complete Binary Tree)
- 마지막 레벨을 제외한 모든 레벨이 꽉 참
- 마지막 레벨은 왼쪽부터 연속적으로 채워짐
- 배열로 구현하기 최적
- **배열 인덱스 공식 (0부터 시작)**:
  - 부모: (i-1)/2 (정수 나눗셈)
  - 왼쪽 자식: 2i+1
  - 오른쪽 자식: 2i+2

### 정 이진트리 (Proper/Strict Binary Tree)
- 모든 내부 노드가 정확히 2개의 자식을 가짐
- 자식이 1개인 노드는 절대 없음 (0개 또는 2개만 허용)
- 리프 노드 수 = 내부 노드 수 + 1
- 전체 노드 수 = 2 × 리프 노드 수 - 1

### 편향 이진트리 (Skewed Binary Tree)
- 모든 노드가 한쪽 방향으로만 자식을 가지는 트리
- 왼쪽 편향 또는 오른쪽 편향
- **선형 자료구조와의 차이점**:
  - 메모리 오버헤드: 사용하지 않는 포인터로 인한 메모리 낭비
  - 의미적 차이: 균형이 깨진 트리 vs 순서가 있는 데이터
  - 확장 가능성: 나중에 균형을 맞출 수 있음
- 시간복잡도는 선형 구조와 동일하게 O(n)

## 5. 이진트리 순회 (Binary Tree Traversal)

### 순회의 필요성
- 트리의 모든 데이터를 처리하고 싶을 때
- 트리 구조를 출력하거나 복사할 때
- 특정 조건의 노드를 찾을 때

### 이진트리 순회 방법
이진트리에서는 **언제 현재 노드를 처리하느냐**에 따라 3가지 순회 방법이 있음

#### 순회 방식 표기법 (약자 의미)
- **V (Visit)**: 현재 노드를 방문(처리)
- **L (Left)**: 왼쪽 서브트리로 이동
- **R (Right)**: 오른쪽 서브트리로 이동

#### 전위 순회 (Preorder): V-L-R
- **현재 노드 처리 → 왼쪽 서브트리 → 오른쪽 서브트리**
- 노드에 방문하자마자 즉시 처리

```python
# 1. 재귀 방식
def preorder_recursive(root):
    if root is None:
        return
    
    print(root.val)  # 현재 노드 처리
    preorder_recursive(root.left)   # 왼쪽 서브트리
    preorder_recursive(root.right)  # 오른쪽 서브트리
    
# 2. 반복문 방식 (스택 사용)
def preorder_iterative(root):
    if root is None:
        return
    
    stack = [root]
    
    while stack:
        node = stack.pop()
        print(node.val)  # 현재 노드 처리
        
        # 오른쪽 먼저 스택에 넣기 (나중에 처리)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
```

#### 중위 순회 (Inorder): L-V-R
- **왼쪽 서브트리 → 현재 노드 처리 → 오른쪽 서브트리**
- 왼쪽 서브트리를 모두 처리한 후 현재 노드 처리
- **이진 탐색 트리에서 중위 순회하면 정렬된 순서로 출력됨**

```python
# 1. 재귀 방식
def inorder_recursive(root):
    if root is None:
        return
    
    inorder_recursive(root.left)   # 왼쪽 서브트리
    print(root.val)                # 현재 노드 처리
    inorder_recursive(root.right)  # 오른쪽 서브트리

# 2. 반복문 방식 (스택 사용)
def inorder_iterative(root):
    stack = []
    current = root
    
    while stack or current:
        # 왼쪽 끝까지 가면서 스택에 저장
        while current:
            stack.append(current)
            current = current.left
        
        # 스택에서 꺼내서 처리
        current = stack.pop()
        print(current.val)  # 현재 노드 처리
        
        # 오른쪽 서브트리로 이동
        current = current.right
```

#### 후위 순회 (Postorder): L-R-V
- **왼쪽 서브트리 → 오른쪽 서브트리 → 현재 노드 처리**
- 양쪽 서브트리를 모두 처리한 후 현재 노드 처리
- 트리 삭제, 디렉토리 크기 계산 등에 유용

```python
# 1. 재귀 방식
def postorder_recursive(root):
    if root is None:
        return
    
    postorder_recursive(root.left)   # 왼쪽 서브트리
    postorder_recursive(root.right)  # 오른쪽 서브트리
    print(root.val)                  # 현재 노드 처리

# 2. 반복문 방식 (스택 2개 사용)
def postorder_iterative(root):
    if root is None:
        return
    
    stack1 = [root]
    stack2 = []
    
    # 첫 번째 스택으로 V-R-L 순서로 탐색
    while stack1:
        node = stack1.pop()
        stack2.append(node)
        
        if node.left:
            stack1.append(node.left)
        if node.right:
            stack1.append(node.right)
    
    # 두 번째 스택에서 꺼내면 L-R-V 순서
    while stack2:
        node = stack2.pop()
        print(node.val)
```

#### 레벨 순회 (Level Order)
- **레벨별로 왼쪽부터 오른쪽으로 순회**
- 큐(Queue)를 사용하여 구현

```python
from collections import deque

def level_order(root):
    if root is None:
        return
    
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        print(node.val)  # 현재 노드 처리
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
```

### 노드 클래스 정의
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

### 핵심 포인트
**"언제 현재 노드를 처리하느냐"가 각 순회 방식의 차이점**