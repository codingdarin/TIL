# 분할 정복 알고리즘 TIL

## 분할 정복(Divide and Conquer) 개념

### 정의
- 큰 문제를 작은 문제들로 나누어서 해결하는 방법
- 큰 문제를 더 작은 하위 문제들로 분할하여 각각 해결한 후 결과를 합치는 접근법

### 3단계 과정
1. **분할(Divide)**: 문제를 더 작은 하위 문제들로 나눈다
2. **정복(Conquer)**: 하위 문제들을 재귀적으로 해결한다
3. **결합(Combine)**: 하위 문제들의 해답을 합쳐서 원래 문제의 해답을 구한다

### 분할 정복 vs 재귀 DP
- **분할 정복**: 하위 문제들이 독립적, 겹치지 않음
- **재귀 DP**: 하위 문제들이 겹침, 메모이제이션 필요

## 병합정렬(Merge Sort)

### 동작 과정
1. 배열을 반으로 계속 나눔 (길이가 1이 될 때까지)
2. 길이가 1인 배열들은 이미 정렬된 상태
3. 정렬된 두 배열을 합쳐서 더 큰 정렬된 배열을 만듦

### 병합(Merge) 과정
- 정렬된 두 배열을 합칠 때 각각의 앞쪽부터 비교
- 더 작은 값을 먼저 결과 배열에 넣음
- 한쪽이 끝나면 다른 쪽 남은 원소들을 모두 복사

### 코드 구현
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result
```

### 시간복잡도: O(n log n)
- **분할 깊이**: log n번 (배열을 반으로 계속 나누므로)
- **각 깊이에서 병합 시간**: O(n) (모든 원소를 한 번씩 처리)
- **총 시간복잡도**: log n × n = O(n log n)

### 특징
- **장점**: 안정 정렬, 최악의 경우도 O(n log n) 보장
- **단점**: O(n)의 추가 메모리 필요

## 퀵정렬(Quick Sort)

### 기본 아이디어
1. 피벗(pivot) 하나를 선택
2. 피벗보다 작은 값들은 왼쪽, 큰 값들은 오른쪽으로 분할
3. 왼쪽과 오른쪽을 각각 재귀적으로 정렬

### 병합정렬과의 차이점
- **병합정렬**: 일단 반으로 나누고 → 나중에 정렬하며 병합
- **퀵정렬**: 정렬하며 나누고 → 나중에 그냥 합치기만 하면 됨

### 간단한 구현 (새 배열 생성)
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[0]  # 맨 왼쪽을 피벗으로
    left = []
    right = []
    
    for i in range(1, len(arr)):
        if arr[i] < pivot:
            left.append(arr[i])
        else:
            right.append(arr[i])
    
    return quick_sort(left) + [pivot] + quick_sort(right)
```

### 중복값 처리 (3-way partition)
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[0]
    left = []
    equal = []  # 같은 값들을 따로 모음
    right = []
    
    for num in arr:
        if num < pivot:
            left.append(num)
        elif num == pivot:
            equal.append(num)
        else:
            right.append(num)
    
    return quick_sort(left) + equal + quick_sort(right)
```

## 호어 파티션(Hoare Partition)

### 특징
- 양방향 포인터 사용 (i: 왼쪽→오른쪽, j: 오른쪽→왼쪽)
- 두 포인터가 만날 때까지 진행
- 찰스 호어가 1961년에 개발한 원조 파티션 방식

### 제자리 정렬 구현
```python
def quick_sort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)

def partition(arr, low, high):
    pivot = arr[low]  # 맨 왼쪽이 피벗
    i = low + 1       # 왼쪽 포인터
    j = high          # 오른쪽 포인터
    
    while i <= j:
        # 왼쪽에서 피벗보다 큰 값 찾기
        while i <= high and arr[i] <= pivot:
            i += 1
        # 오른쪽에서 피벗보다 작은 값 찾기
        while j >= low and arr[j] > pivot:
            j -= 1
        # 두 포인터가 만나지 않았으면 교환
        if i < j:
            arr[i], arr[j] = arr[j], arr[i]
    
    # 피벗을 올바른 자리에 배치
    arr[low], arr[j] = arr[j], arr[low]
    return j
```

### 효율성 비교
- **새 배열 방식**: 구현 간단, 메모리 비효율 O(n log n)
- **파티션 방식**: 메모리 효율 O(log n), 속도 빠름

### 시간복잡도
- **평균**: O(n log n)
- **최악**: O(n²) - 피벗이 항상 극값일 때 (예: 이미 정렬된 배열)
- **최선**: O(n log n)

### 피벗 선택의 중요성
- **첫 번째/마지막 원소**: 구현 간단, 최악의 경우 가능성
- **중간값 선택**: 더 안정적 성능
- **랜덤 선택**: 평균적으로 좋은 성능

## 이진 탐색(Binary Search)

### 기본 아이디어
- 정렬된 배열에서 특정 값을 찾는 알고리즘
- 중간값과 비교해서 범위를 반으로 줄여나가는 분할 정복 방식

### 동작 과정
1. 배열의 중간 원소를 확인
2. 찾는 값이 중간값보다 작으면 → 왼쪽 절반에서 찾기
3. 찾는 값이 중간값보다 크면 → 오른쪽 절반에서 찾기
4. 같으면 → 찾았다!

### 재귀 구현
```python
def binary_search(arr, target, left, right):
    # 기저 조건: 범위가 유효하지 않으면 못 찾음
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid  # 찾았다!
    elif arr[mid] > target:
        # 왼쪽 절반에서 찾기
        return binary_search(arr, target, left, mid - 1)
    else:
        # 오른쪽 절반에서 찾기
        return binary_search(arr, target, mid + 1, right)
```

### 반복문 구현
```python
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] > target:
            right = mid - 1  # 왼쪽으로 범위 축소
        else:
            left = mid + 1   # 오른쪽으로 범위 축소
    
    return -1  # 못 찾음
```

### 시간복잡도: O(log n)
- 매번 탐색 범위가 절반으로 줄어듦
- 최대 log n번의 비교로 결과 도출

### 전제 조건
- **반드시 정렬된 배열**이어야 함
- 정렬되지 않은 배열에서는 사용 불가

### 응용
- 상한/하한 탐색 (upper bound, lower bound)
- 파라메트릭 서치 (parametric search)
- 결정 문제를 최적화 문제로 변환