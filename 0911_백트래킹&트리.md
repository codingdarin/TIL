# 백트래킹(Backtracking) 학습 정리

## 백트래킹 개념

### 정의
- **모든 경우의 수를 탐색하되, 조건에 맞지 않으면 즉시 되돌아가는** 알고리즘 기법
- 미로 탈출과 유사: 막다른 길에 도달하면 되돌아가서 다른 길 시도

### 특징
- **DFS(깊이 우선 탐색) 기반**으로 동작
- **가지치기(Pruning)**를 통해 불필요한 탐색 제거
- **재귀함수**로 구현하는 것이 일반적
- 백트래킹 = DFS + 가지치기

## 백트래킹 vs DFS 차이점

| 구분 | DFS | 백트래킹 |
|------|-----|----------|
| 탐색 방식 | 모든 노드를 끝까지 탐색 | 조건에 맞지 않으면 즉시 되돌아감 |
| 효율성 | 모든 경우 확인 | 가지치기로 불필요한 탐색 제거 |
| 용도 | 그래프 탐색 | 해 찾기 문제 |

## 핵심 요소

### 1. 가지치기(Pruning)
- 불필요한 경우의 수를 미리 제거하는 기법
- 백트래킹의 핵심 최적화 방법

### 2. 상태 복원
- 되돌아갈 때 이전 상태로 정확히 복원
- 문제에 따라 명시적 복원이 필요한 경우가 있음

### 3. 기본 템플릿
```python
def backtrack():
    # 기저 조건: 해를 찾았거나 더 이상 진행 불가
    if 조건:
        return
    
    for 선택지 in 가능한_선택들:
        if 유효성_검사(선택지):
            # 선택
            상태_변경(선택지)
            
            # 재귀
            backtrack()
            
            # 되돌리기 (필요한 경우)
            상태_복원(선택지)
```

## 시간복잡도

### 이론적 복잡도
- **최악의 경우**: O(b^d) (b=분기계수, d=깊이)
- **N-Queen 예시**: N^N (전체 경우의 수)

### 실제 성능
- 가지치기 덕분에 **실제로는 훨씬 빠르게** 동작
- 적절한 조건 검사와 휴리스틱 적용시 지수적 시간 단축

## 상태 공간 트리 (4-Queen 예시)

```
                    루트(시작)
                       |
            ┌─────┬─────┼─────┬─────┐
           (0,0) (0,1) (0,2) (0,3)  ← 1행에 퀸 배치
            |     |     |     |
        ┌─┬─┼─┬─ ...  ...  ┌─┬─┼─┬─┐
      (1,0)(1,1)(1,2)(1,3)  (1,0)(1,1)(1,2)(1,3) ← 2행에 퀸 배치
        |   X   X   |        |   X   X   |
```

- 각 레벨은 의사결정 단계를 나타냄
- X 표시는 가지치기로 제거된 불가능한 경우
- 백트래킹 없이는 256개 노드, 백트래킹으로 대폭 감소

## 실습 예제

### 1. 순열 생성 (명시적 복원 필요)
```python
def generate_permutations(nums):
    result = []
    path = []
    used = [False] * len(nums)
    
    def backtrack():
        if len(path) == len(nums):
            result.append(path[:])
            return
        
        for i in range(len(nums)):
            if used[i]:
                continue
            
            # 선택
            path.append(nums[i])
            used[i] = True
            
            # 재귀
            backtrack()
            
            # 복원 (핵심!)
            path.pop()
            used[i] = False
    
    backtrack()
    return result
```

### 2. N-Queen 문제 (자동 복원)
```python
def solve_n_queen(n):
    board = [-1] * n  # board[i] = j: i행 j열에 퀸 위치
    solutions = []
    
    def is_safe(row, col):
        # 같은 열 검사
        for i in range(row):
            if board[i] == col:
                return False
        
        # 대각선 검사
        for i in range(row):
            if abs(board[i] - col) == abs(i - row):
                return False
        
        return True
    
    def backtrack(row):
        if row == n:
            solutions.append(board[:])
            return
        
        for col in range(n):
            if is_safe(row, col):
                board[row] = col
                backtrack(row + 1)
                # 자동 복원 (다음 반복에서 덮어씀)
    
    backtrack(0)
    return solutions
```

## 휴리스틱(Heuristic)

### 정의
- 경험에 기반한 규칙으로 더 빠르게 좋은 결과를 찾는 방법
- 정확한 답을 보장하지는 않지만 효율성 향상

### 적용 예시
- **스도쿠**: 가능한 숫자가 적은 칸부터 탐색
- **N-Queen**: 공격받는 칸이 적은 위치부터 탐색
- **일반적**: 제약이 많은 변수부터 처리

### 효과
- 좋은 해를 빨리 발견
- 가지치기 효과 증대
- 주의: 잘못된 휴리스틱은 오히려 성능 저하 가능

## 대표적인 백트래킹 문제들
- N-Queen 문제
- 스도쿠 해결
- 순열/조합 생성
- 그래프 컬러링
- 외판원 문제 (TSP)
- 부분집합 생성


# 트리(Tree) 자료구조 학습 정리

## 트리 개념

### 정의
- **계층적 구조**를 가진 자료구조
- 하나의 루트(Root)에서 시작하여 부모-자식 관계로 연결
- **사이클이 없고 연결되어 있는** 구조

### 기본 용어
- **노드(Node)**: 트리의 각 요소
- **루트(Root)**: 가장 위의 노드, 부모가 없는 노드
- **부모(Parent)**: 바로 위 레벨의 노드
- **자식(Children)**: 바로 아래 레벨의 노드들
- **리프(Leaf)**: 자식이 없는 노드
- **간선(Edge) = 가지(Branch)**: 노드와 노드를 연결하는 선

### 트리의 특징
- n개의 노드가 있으면 n-1개의 간선이 존재
- 루트를 제외한 모든 노드는 정확히 하나의 부모를 가짐

## 이진트리(Binary Tree)

### 정의
- **각 노드가 최대 2개의 자식**을 가질 수 있는 트리
- 왼쪽 자식(Left Child)과 오른쪽 자식(Right Child) 구분

### 이진트리의 종류
- **포화 이진트리(Full Binary Tree)**: 모든 리프가 같은 레벨, 모든 내부 노드가 2개 자식
- **완전 이진트리(Complete Binary Tree)**: 마지막 레벨 제외하고 모든 레벨이 가득 참
- **편향 이진트리(Skewed Binary Tree)**: 한쪽으로 치우친 트리

### 이진트리 순회(Traversal)

#### 1. 전위순회 (Pre-order): 루트 → 왼쪽 → 오른쪽
```python
def preorder(node):
    if node:
        print(node.data)      # 루트 먼저
        preorder(node.left)   # 왼쪽
        preorder(node.right)  # 오른쪽
```
- **용도**: 트리 복사, 디렉토리 구조 출력, 수식 트리 전위 표기법

#### 2. 중위순회 (In-order): 왼쪽 → 루트 → 오른쪽
```python
def inorder(node):
    if node:
        inorder(node.left)    # 왼쪽 먼저
        print(node.data)      # 루트
        inorder(node.right)   # 오른쪽
```
- **용도**: 이진 탐색 트리에서 정렬된 순서로 출력

#### 3. 후위순회 (Post-order): 왼쪽 → 오른쪽 → 루트
```python
def postorder(node):
    if node:
        postorder(node.left)  # 왼쪽 먼저
        postorder(node.right) # 오른쪽
        print(node.data)      # 루트 마지막
```
- **용도**: 메모리 해제, 디렉토리 삭제, 트리 크기 계산

#### 4. 레벨순회 (Level-order)
- **BFS 방식**: 같은 레벨을 먼저 다 방문
- **용도**: 트리를 레벨별로 출력, 최단경로

## 노드 번호의 특성 (완전 이진트리)

### 배열 인덱스 기반 관계
- **부모 노드**: `i번 노드의 부모 = i // 2`
- **왼쪽 자식**: `i번 노드의 왼쪽 자식 = 2 * i`
- **오른쪽 자식**: `i번 노드의 오른쪽 자식 = 2 * i + 1`

### 레벨 정보
- **레벨 k**에는 **2^(k-1)개**의 노드
- **노드 i의 레벨**: `floor(log2(i)) + 1`

## 이진트리 표현 방법

### 1. 배열 표현
```python
# 완전 이진트리에서 효율적
tree = [None, 1, 2, 3, 4, 5, 6, 7]  # 인덱스 1부터 사용

def parent(i): return i // 2
def left_child(i): return 2 * i
def right_child(i): return 2 * i + 1
```

**장점**: 메모리 효율적 (완전 이진트리에서), 인덱스 계산 간단
**단점**: 편향 트리에서 메모리 낭비, 동적 크기 조절 어려움

### 2. 연결리스트 표현
```python
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
```

**장점**: 메모리 효율적 (실제 노드만 사용), 동적 크기, 유연한 삽입/삭제
**단점**: 추가 포인터 메모리, 부모 접근 어려움

### 3. 딕셔너리 표현
```python
tree = {
    'A': {'left': 'B', 'right': 'C'},
    'B': {'left': 'D', 'right': None},
    'C': {'left': 'E', 'right': 'F'}
}
```

**장점**: 모든 트리 구조 적용, 키로 직접 접근
**단점**: 별도 부모 정보 저장 필요

## 이진탐색트리(Binary Search Tree, BST)

### 정의와 규칙
- 왼쪽 서브트리의 모든 값 < 루트
- 오른쪽 서브트리의 모든 값 > 루트
- 모든 서브트리도 이진탐색트리

### 주요 연산

#### 탐색 - O(log n)
```python
def search(root, target):
    if not root or root.data == target:
        return root
    
    if target < root.data:
        return search(root.left, target)
    else:
        return search(root.right, target)
```

#### 삽입 - O(log n)
```python
def insert(root, data):
    if not root:
        return TreeNode(data)
    
    if data < root.data:
        root.left = insert(root.left, data)
    elif data > root.data:
        root.right = insert(root.right, data)
    
    return root
```

#### 삭제 - O(log n)
**3가지 경우**:
1. **리프 노드**: 그냥 삭제
2. **자식 1개**: 자식을 부모와 직접 연결
3. **자식 2개**: 후계자(오른쪽 서브트리의 최솟값)로 대체

```python
def delete(root, data):
    if not root:
        return root
    
    if data < root.data:
        root.left = delete(root.left, data)
    elif data > root.data:
        root.right = delete(root.right, data)
    else:
        # 자식이 0개 또는 1개
        if not root.left:
            return root.right
        if not root.right:
            return root.left
        
        # 자식이 2개: 후계자로 대체
        successor = find_min(root.right)
        root.data = successor.data
        root.right = delete(root.right, successor.data)
    
    return root
```

### BST의 특징
- **중위순회 시 자동으로 오름차순 정렬**
- 평균 시간복잡도: O(log n)
- 최악 시간복잡도: O(n) - 편향 트리가 될 때

## 힙(Heap)

### 정의
- **우선순위 큐**를 구현하는 **완전 이진트리**
- **힙 속성(Heap Property)** 만족

### 힙의 종류

#### 1. 최대 힙(Max Heap)
- **부모 ≥ 자식** (부모가 항상 더 크거나 같음)
- 루트에 **최댓값** 위치

#### 2. 최소 힙(Min Heap)
- **부모 ≤ 자식** (부모가 항상 더 작거나 같음)
- 루트에 **최솟값** 위치

### 주요 연산

#### 삽입 (Heapify Up) - O(log n)
```python
def insert(heap, data):
    heap.append(data)
    heapify_up(heap, len(heap) - 1)

def heapify_up(heap, i):
    parent = (i - 1) // 2
    
    if i > 0 and heap[i] < heap[parent]:
        heap[i], heap[parent] = heap[parent], heap[i]
        heapify_up(heap, parent)
```

#### 삭제 (Heapify Down) - O(log n)
```python
def delete_min(heap):
    if len(heap) == 0:
        return None
    
    min_val = heap[0]
    heap[0] = heap[-1]
    heap.pop()
    heapify_down(heap, 0)
    return min_val

def heapify_down(heap, i):
    left = 2 * i + 1
    right = 2 * i + 2
    smallest = i
    
    if left < len(heap) and heap[left] < heap[smallest]:
        smallest = left
    
    if right < len(heap) and heap[right] < heap[smallest]:
        smallest = right
    
    if smallest != i:
        heap[i], heap[smallest] = heap[smallest], heap[i]
        heapify_down(heap, smallest)
```

### 힙의 장점
- **최댓값/최솟값 접근**: O(1)
- **삽입/삭제**: O(log n)
- **배열로 구현** 가능 → 메모리 효율적

## 힙 vs Sort 비교

### 사용 시나리오에 따른 선택

| 상황 | Sort 방식 | Heap 방식 | 권장 |
|------|-----------|-----------|------|
| 전체 정렬 필요 | O(n log n) | 불필요 | **Sort** |
| 최댓값 1개 | O(n log n) | O(n) + O(log n) | **Heap** |
| 최댓값 k개 | O(n log n) | O(n log k) | **Heap** |
| 동적 삽입/삭제 | O(n log n) 매번 | O(log n) | **Heap** |

### 힙이 유리한 경우
- **데이터 삽입/삭제가 잦을 때**
- **실시간 순위 시스템**
- **우선순위 큐** 구현
- **스트리밍 데이터에서 Top K** 찾기

### 실제 사용 예시
```python
# 실시간 게임 점수 관리
import heapq

# Sort 방식: 매번 O(n log n)
def add_score_sort(scores, new_score):
    scores.append(new_score)
    scores.sort(reverse=True)
    return scores[0]

# Heap 방식: 매번 O(log n)
max_heap = []
def add_score_heap(heap, new_score):
    heapq.heappush(heap, -new_score)  # 최대힙
    return -heap[0]
```

**성능 차이**: 1000개 데이터에서 100번 삽입 시 **1000배 성능 차이** 발생