# Python 2차원 리스트 TIL

## 2차원 리스트 (2D List)

### 정의
- **1차원 리스트를 묶어놓은 리스트**
- 2차원 이상의 다차원 리스트는 차원에 따라 인덱스를 선언
- 2차원 리스트의 선언: 세로길이(행)와 가로길이(열)를 필요로 함
- 파이썬에서는 데이터 초기화를 통해 변수선언과 초기화가 가능함

### 구조와 인덱싱

| 행\열 | 0 | 1 | 2 | 3 |
|-------|---|---|---|---|
| **0** | 0 | 1 | 2 | 3 |
| **1** | 4 | 5 | 6 | 7 |

```python
arr = [
    [0, 1, 2, 3],
    [4, 5, 6, 7]
]

print(arr[0][1])  # 1 (0행 1열)
print(arr[1][3])  # 7 (1행 3열)
```

---

## 2차원 리스트 생성 방법

### 1. 직접 생성
```python
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

### 2. 0으로 채워진 배열 생성
```python
# 올바른 방법 - 3행 4열
arr = [[0] * 4 for _ in range(3)]

# 잘못된 방법 (주의!)
arr = [[0] * 4] * 3  # 같은 리스트 객체를 참조
arr[0][0] = 1
print(arr)  # [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]
```

### 3. 다양한 초기화 방법
```python
# 모든 값을 1로 초기화
arr = [[1] * 3 for _ in range(4)]

# 행 번호로 초기화
arr = [[i] * 3 for i in range(4)]
# [[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]]

# 행과 열의 합으로 초기화
arr = [[i + j for j in range(3)] for i in range(4)]
# [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]
```

---

## 입력을 2차원 배열에 저장하기

### 공백으로 구분된 숫자 입력
```python
# 입력 예시:
# 3
# 1 2 3
# 4 5 6
# 7 8 9

N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
```

### 붙어있는 숫자 입력
```python
# 입력 예시:
# 3
# 123
# 456
# 789

N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
```

### 문자열 입력
```python
# 입력 예시:
# 3
# abc
# def
# ghi

N = int(input())
arr = [list(input()) for _ in range(N)]
```

---

## 2차원 리스트 순회하기

### 1. 행 우선 순회 (기본)
```python
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 모든 요소 출력
for i in range(len(arr)):
    for j in range(len(arr[i])):
        print(arr[i][j], end=' ')
    print()

# 전체 합 구하기
total_sum = 0
for i in range(len(arr)):
    for j in range(len(arr[i])):
        total_sum += arr[i][j]
```

### 2. 열 우선 순회
```python
# 세로 방향으로 순회
for j in range(len(arr[0])):     # 열 인덱스
    for i in range(len(arr)):    # 행 인덱스
        print(arr[i][j], end=' ')
    print()
```

### 3. 지그재그 순회
```python
# 짝수 행은 좌→우, 홀수 행은 우→좌
for i in range(len(arr)):
    if i % 2 == 0:  # 짝수 행
        for j in range(len(arr[i])):
            print(arr[i][j], end=' ')
    else:  # 홀수 행
        for j in range(len(arr[i]) - 1, -1, -1):
            print(arr[i][j], end=' ')
    print()

#이중 for문으로 쓰면
    for i in range(n):
      for j in range(m):
          print(arr[i][j + (m-1-2*j) * (i%2)])

# 출력:
# 1 2 3 
# 6 5 4 
# 7 8 9 
```

### 4. 대각선 순회
```python
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 주대각선 순회 (↘ 방향)
print("주대각선:")
for i in range(len(arr)):
    j = i  # i와 j가 같이 증가
    print(arr[i][j], end=' ')  # 1 5 9

# 부대각선 순회 (↙ 방향)  
print("\n부대각선:")
for i in range(len(arr)):
    j = len(arr) - 1 - i  # i는 증가, j는 감소
    print(arr[i][j], end=' ')  # 3 5 7

```

#### 대각선 공식의 원리
```python
# 부대각선에서 j = n-1-i 패턴:
# - i는 증가 (0→1→2)
# - j는 감소 (2→1→0)
# - 고정값(n-1)에서 증가하는 값(i)을 빼면 감소하는 값 생성

# n=3일 때:
# i=0: j = 3-1-0 = 2  → arr[0][2]
# i=1: j = 3-1-1 = 1  → arr[1][1] 
# i=2: j = 3-1-2 = 0  → arr[2][0]

```

### 참고_ X자 대각선 순회 시 중심점 중복 주의
```python
# X자로 순회할 때 중심원소가 2번 계산되는 문제
n = 3  # 홀수 크기 배열

# 주대각선 + 부대각선 순회
total = 0
for i in range(n):
   total += arr[i][i]        # 주대각선
   total += arr[i][n-1-i]    # 부대각선
   # arr[1][1] (중심점)이 2번 더해짐!

# 해결방법: 홀수 크기일 때 중심점 한 번 빼기
center = n // 2
if n % 2 == 1:  # 홀수일 때만
   total -= arr[center][center]
```

---

## 2차원 리스트 연산

### 합계 구하기
```python
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# 전체 합
total = sum(sum(row) for row in arr)

# 행별 합
for i, row in enumerate(arr):
    print(f"{i}행의 합: {sum(row)}")

# 열별 합
for j in range(len(arr[0])):
    col_sum = sum(arr[i][j] for i in range(len(arr)))
    print(f"{j}열의 합: {col_sum}")
```

### 최댓값과 위치 찾기
```python
arr = [[1, 9, 3], [4, 5, 2], [7, 8, 6]]

# 최댓값과 위치
max_val = arr[0][0]
max_pos = (0, 0)

for i in range(len(arr)):
    for j in range(len(arr[i])):
        if arr[i][j] > max_val:
            max_val = arr[i][j]
            max_pos = (i, j)

print(f"최댓값: {max_val}, 위치: {max_pos}")
```

---


## 2차원 리스트 변형

### 전치 (Transpose)

#### 방법 1: 새 배열 생성
```python
arr = [[1, 2, 3], [4, 5, 6]]

# 리스트 컴프리헨션
transposed = [[arr[i][j] for i in range(len(arr))] 
              for j in range(len(arr[0]))]

# zip 사용 (더 간단)
transposed = list(map(list, zip(*arr)))
# [[1, 4], [2, 5], [3, 6]]
```

#### 방법 2: 제자리 교환 (정방행렬만)
```python
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# 대각선 기준으로 위아래 교환
for i in range(len(arr)):
    for j in range(i+1, len(arr)):  # 대각선 위쪽만
        arr[i][j], arr[j][i] = arr[j][i], arr[i][j]

# 결과: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
```

### 90도 회전
```python
def rotate_90(arr):
    """시계방향 90도 회전"""
    n = len(arr)
    m = len(arr[0])
    rotated = [[0] * n for _ in range(m)]
    
    for i in range(n):
        for j in range(m):
            rotated[j][n-1-i] = arr[i][j]
    
    return rotated
```


**변경점**: 전치를 **"새 배열 생성"**과 **"제자리 교환"** 두 방법으로 나누어 설명했습니다!

---



## 부분배열 (Subarray)

### 정의
배열의 연속된 일부분으로, 원본 배열에서 인덱스가 연속인 요소들로 구성됩니다.

### 1차원 부분배열
```python
arr = [1, 2, 3, 4, 5]

# 모든 부분배열 찾기
for i in range(len(arr)):           # 시작점
    for j in range(i, len(arr)):    # 끝점
        subarray = arr[i:j+1]
        print(f"arr[{i}:{j+1}] = {subarray}")

# 출력:
# arr[0:1] = [1]
# arr[0:2] = [1, 2]
# arr[0:3] = [1, 2, 3]
# ...
# arr[4:5] = [5]
```

### 2차원 부분배열 (직사각형 영역)
```python
arr = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

# 모든 직사각형 부분배열 찾기 (4중 for문)
for x1 in range(len(arr)):              # 시작 행
    for y1 in range(len(arr[0])):       # 시작 열
        for x2 in range(x1, len(arr)):          # 끝 행
            for y2 in range(y1, len(arr[0])):   # 끝 열
                print(f"부분배열 ({x1},{y1}) ~ ({x2},{y2}):")
                
                # 해당 영역 출력
                for i in range(x1, x2+1):
                    for j in range(y1, y2+1):
                        print(arr[i][j], end=' ')
                    print()
                print("---")
```

### 고정 크기 부분배열 (슬라이딩 윈도우)
```python
# 3x2 크기의 부분배열 모두 찾기
def find_fixed_subarrays(arr, height, width):
    n = len(arr)        # 전체 행 개수
    m = len(arr[0])     # 전체 열 개수
    
    # 시작점의 범위: (n-height+1) x (m-width+1)
    for i in range(n - height + 1):     # 0 to n-height
        for j in range(m - width + 1):  # 0 to m-width
            print(f"시작점 ({i},{j})에서 {height}x{width} 부분배열:")
            
            # height x width 영역 처리
            for x in range(i, i + height):
                for y in range(j, j + width):
                    print(arr[x][y], end=' ')
                print()
            print("---")

# 사용 예시
arr = [
    [1, 2, 3, 4],
    [5, 6, 7, 8], 
    [9, 10, 11, 12]
]

find_fixed_subarrays(arr, 2, 3)  # 2x3 크기 부분배열
```

### 부분배열의 합 구하기
```python
def subarray_sum(arr, x1, y1, x2, y2):
    """(x1,y1)부터 (x2,y2)까지 부분배열의 합"""
    total = 0
    for i in range(x1, x2+1):
        for j in range(y1, y2+1):
            total += arr[i][j]
    return total

# 최대 합 부분배열 찾기 (브루트포스)
def max_subarray_sum(arr):
    max_sum = float('-inf')
    best_coords = None
    
    for x1 in range(len(arr)):
        for y1 in range(len(arr[0])):
            for x2 in range(x1, len(arr)):
                for y2 in range(y1, len(arr[0])):
                    current_sum = subarray_sum(arr, x1, y1, x2, y2)
                    if current_sum > max_sum:
                        max_sum = current_sum
                        best_coords = (x1, y1, x2, y2)
    
    return max_sum, best_coords
```

### 시간복잡도 주의사항
- **4중 for문**: O(N⁴) - 배열 크기가 커지면 매우 느림
- **최적화 방법**: 구간합(Prefix Sum) 사용하여 O(N²)로 개선 가능



---

## 델타 탐색 (상하좌우 이동)

### 4방향 탐색
```python
# 상, 하, 좌, 우
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
x, y = 1, 1  # 현재 위치

for i in range(4):
    nx = x + dx[i]
    ny = y + dy[i]
    
    # 범위 체크
    if 0 <= nx < len(arr) and 0 <= ny < len(arr[0]):
        print(f"방향 {i}: {arr[nx][ny]}")
```

### 8방향 탐색 (대각선 포함)
```python
# 상, 하, 좌, 우, 좌상, 우상, 좌하, 우하
dx = [-1, 1, 0, 0, -1, -1, 1, 1]
dy = [0, 0, -1, 1, -1, 1, -1, 1]

arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
x, y = 1, 1  # 현재 위치

for i in range(8):
    nx = x + dx[i]
    ny = y + dy[i]
    
    if 0 <= nx < len(arr) and 0 <= ny < len(arr[0]):
        print(f"방향 {i}: {arr[nx][ny]}")
```

### 델타 탐색 심화

#### 방법 1: 전체 배열 탐색 패턴
```python
# NxN 배열의 모든 칸에서 4방향 인접 칸 확인
di = [0, 1, 0, -1]  # 우, 하, 좌, 상
dj = [1, 0, -1, 0]

for i in range(N):
    for j in range(N):
        for d in range(4):
            ni = i + di[d]
            nj = j + dj[d]
            if 0 <= ni < N and 0 <= nj < N:
                # arr[ni][nj] 처리
                pass
```

#### 방법 2: 튜플 리스트 활용
```python
# 델타 배열을 튜플 리스트로 간단하게
directions = [(0,1), (1,0), (0,-1), (-1,0)]

for i in range(N):
    for j in range(N):
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if 0 <= ni < N and 0 <= nj < N:
                # arr[ni][nj] 처리
                pass
```

#### K칸 확장 탐색 (십자가 모양)
```python
# 교안
max_v = 0
for i in range(N):
    for j in range(N):
        s = arr[i][j]  # 중심값
        for di, dj in [(0,1),(1,0),(0,-1),(-1,0)]:  # 4방향
            for c in range(1, k+1):  # K칸까지
                ni, nj = i+di*c, j+dj*c
                if 0<=ni<N and 0<=nj<N:
                    s += arr[ni][nj]
        if max_v < s:
            max_v = s


# 각 위치에서 상하좌우로 K칸까지 탐색
def cross_search(arr, start_i, start_j, k):
    """(start_i, start_j)에서 십자가 모양으로 K칸까지 탐색"""
    N = len(arr)
    directions = [(0,1), (1,0), (0,-1), (-1,0)]  # 우, 하, 좌, 상
    
    total = arr[start_i][start_j]  # 중심값
    
    for di, dj in directions:
        for distance in range(1, k+1):  # 1칸부터 K칸까지
            ni = start_i + di * distance
            nj = start_j + dj * distance
            
            if 0 <= ni < N and 0 <= nj < N:
                total += arr[ni][nj]
            else:
                break  # 범위 벗어나면 해당 방향 중단
    
    return total

# 사용 예시: NxN 배열에서 각 위치의 십자가 합 중 최댓값
max_sum = 0
for i in range(N):
    for j in range(N):
        cross_sum = cross_search(arr, i, j, k)
        max_sum = max(max_sum, cross_sum)
```

#### 실전 예시: 상하좌우 인접 칸의 합
```python
def get_adjacent_sum(arr, x, y):
    """(x, y) 위치의 상하좌우 인접 칸들의 합"""
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    
    total = 0
    count = 0
    
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        
        if 0 <= nx < len(arr) and 0 <= ny < len(arr[0]):
            total += arr[nx][ny]
            count += 1
    
    return total, count

# 모든 위치에서 인접 칸 합의 최댓값 찾기
max_adjacent_sum = 0
for i in range(len(arr)):
    for j in range(len(arr[0])):
        adj_sum, _ = get_adjacent_sum(arr, i, j)
        max_adjacent_sum = max(max_adjacent_sum, adj_sum)
```

---

## 실전 예제

### 나선형 배열 생성
```python
def create_spiral(n):
    """n x n 나선형 배열 생성"""
    arr = [[0] * n for _ in range(n)]
    
    # 우, 하, 좌, 상
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    
    x, y = 0, 0
    direction = 0
    
    for i in range(1, n * n + 1):
        arr[x][y] = i
        
        # 다음 위치 계산
        nx = x + dx[direction]
        ny = y + dy[direction]
        
        # 범위를 벗어나거나 이미 채워진 경우 방향 전환
        if (nx < 0 or nx >= n or ny < 0 or ny >= n or 
            arr[nx][ny] != 0):
            direction = (direction + 1) % 4
            nx = x + dx[direction]
            ny = y + dy[direction]
        
        x, y = nx, ny
    
    return arr
```

### 2차원 구간 합
```python
def calculate_prefix_sum(arr):
    """2차원 구간 합 배열 생성"""
    n = len(arr)
    m = len(arr[0])
    
    # 1-indexed로 처리
    prefix = [[0] * (m + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            prefix[i][j] = (arr[i-1][j-1] + 
                          prefix[i-1][j] + 
                          prefix[i][j-1] - 
                          prefix[i-1][j-1])
    
    return prefix

def get_range_sum(prefix, x1, y1, x2, y2):
    """(x1,y1)부터 (x2,y2)까지의 구간 합"""
    return (prefix[x2+1][y2+1] - 
            prefix[x1][y2+1] - 
            prefix[x2+1][y1] + 
            prefix[x1][y1])
```

---

## 주의사항

1. **2차원 리스트 생성 시**: `[[0] * n] * m` 사용 금지 (얕은 복사 문제)
2. **인덱스 범위**: 항상 `0 <= i < len(arr)`, `0 <= j < len(arr[0])` 확인
3. **행과 열 구분**: `arr[행][열]` 순서 주의
4. **델타 탐색**: dx, dy 배열의 순서와 방향 일치시키기