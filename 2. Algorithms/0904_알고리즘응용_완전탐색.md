# 재귀 호출과 완전 탐색

## 학습 목표
- 재귀 호출의 구조와 특성을 이해하고, 이를 활용한 알고리즘을 구현할 수 있다
- 재귀 호출을 이용해 중첩 반복 구조를 구성하고, 완전 탐색 알고리즘을 설계할 수 있다
- 순열, 조합, 부분집합 등 조합적 문제를 재귀 호출로 구현할 수 있다
- 완전 탐색(Brute-force)의 개념을 이해하고, 다양한 조합을 모두 시도하는 문제 해결 전략을 익힌다

## 완전 탐색 (Brute Force)
### 개념
- 모든 가능한 경우를 다 확인해보는 방법
- 확실하지만 시간이 오래 걸릴 수 있음
- 문제의 크기가 작을 때 유용한 접근법

## 반복과 재귀

### 반복문의 특징
- 수행하는 작업이 완료될 때까지 반복
- 루프를 통해 코드를 n번 반복시킬 수 있음
- 명시적인 반복 횟수나 조건으로 제어

### 재귀의 특징  
- 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
- 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합
- **재귀호출은 n중 반복문과 같은 효과**를 낼 수 있음

## 재귀 함수의 핵심 개념

### 함수 호출 시 변수 전달 특징
1. **값 복사**: int 타입 객체를 전달하면 값만 복사됨
   - 원본 변수와 함수 내 변수는 서로 다른 메모리 공간에 존재
   - 마치 같은 이름을 가진 다른 사람처럼 독립적

2. **함수 호출 스택**: 중첩 함수가 끝나면 해당 함수가 호출되었던 곳으로 돌아옴
   - 함수 호출마다 새로운 스택 프레임 생성
   - 함수 종료 시 해당 스택 프레임 제거

### 재귀의 필수 요소
- **기저조건 (Base Case)**: 무한 재귀호출을 막기 위한 종료 조건
- **재귀호출 (Recursive Call)**: 자기 자신을 호출하는 부분

## 재귀의 구조적 특징

### 트리 구조로 이해하기
1. **재귀호출 개수 = 가지의 개수**
   - 각 재귀 호출이 트리의 가지(branch)가 됨
   
2. **종료조건에 따라 깊이가 달라짐**
   - 깊이를 **레벨(Level)**이라고 부름
   - 예: 레벨 3, 브랜치 4인 형태는 for문으로도 표현 가능

### 재귀 vs 반복문
- 재귀는 복잡한 중첩 구조를 간단하게 표현 가능
- 반복문은 직관적이고 메모리 효율적
- 문제의 성격에 따라 적절한 방법 선택 필요

## 조합적 문제에서의 재귀 활용
재귀는 다음과 같은 조합적 문제들을 해결하는데 특히 유용:
- **순열(Permutation)**: 순서가 중요한 나열
- **조합(Combination)**: 순서가 중요하지 않은 선택  
- **부분집합(Subset)**: 전체 집합의 일부분

## 순열 (Permutation)

### 순열의 개념
- 서로 다른 n개 중에서 r개를 **순서를 고려해서** 선택하는 것
- nPr = n! / (n-r)!, 전체 순열(nPn) = n!
- 예: [1,2,3]에서 2개 선택 → (1,2), (1,3), (2,1), (2,3), (3,1), (3,2)

### 중복순열 vs 순열
- **중복순열**: 같은 원소를 여러 번 선택 가능
- **순열**: 한 번 선택한 원소는 다시 선택 불가 (used 배열 필요)

## 순열 구현 방법

### 1. 중복순열 - 리스트 방식 (append/pop)
```python
def duplicate_permutation(arr, path, length):
    if len(path) == length:
        print(path)
        return
    
    for i in range(len(arr)):
        path.append(arr[i])    # 선택
        duplicate_permutation(arr, path, length)
        path.pop()             # 백트래킹 (선택 취소)
```

**백트래킹의 중요성**: 
- `path.pop()` 없으면 원소가 계속 누적되어 무한히 길어짐
- 다음 경우를 시도하기 위해 상태를 원래대로 복구해야 함

### 2. 중복순열 - 배열 방식 (인덱스)
```python
def duplicate_nPk(i, N, K):
    if i == K:
        print(p)
    else:
        for j in range(N):
            p[i] = arr[j]      # 인덱스로 직접 할당
            duplicate_nPk(i+1, N, K)
```

**배열 방식의 장점**:
- `p[i] = arr[j]`로 직접 할당하면 다음 반복에서 자동으로 덮어써짐
- append/pop 없이도 자연스러운 백트래킹 효과
- 메모리 효율적이고 코드가 간결

### 3. 순열 - used 배열 활용
```python
def nPk(i, N, K):
    if i == K:
        print(p)
    else:
        for j in range(N):
            if used[j] == 0:    # 사용되지 않은 원소만 선택
                used[j] = 1     # 사용 표시
                p[i] = arr[j]
                nPk(i+1, N, K)
                used[j] = 0     # 사용 해제 (백트래킹)

# 사용법
N, K = 3, 2
arr = [1,2,3]
used = [0] * N  # 방문 체크 배열
p = [0] * K     # 결과 저장 배열
```

**중복순열 → 순열 변경법**:
- `used` 배열 추가
- `if used[j] == 0:` 조건 추가
- `used[j] = 1`, `used[j] = 0` 백트래킹 추가

## 두 구현 방식 비교

| 구분 | 리스트 방식 | 배열 방식 |
|------|-------------|-----------|
| 크기 | 동적 | 고정 |
| 백트래킹 | 명시적 (append/pop) | 자동적 (덮어쓰기) |
| 성능 | 메모리 할당 오버헤드 | 빠름 |
| 가독성 | 백트래킹 과정 명확 | 간결 |

## 완전탐색 알고리즘 (Brute-Force)
- 모든 가능한 경우를 전부 시도해 정답을 찾아내는 알고리즘
- 모든 문제에서 일단 가장 먼저 떠올려야 할 해결책
- 시간 복잡도를 고려해야 함 (일반적으로 지수적 증가)
- **N중 for문 구조라면 재귀호출로 구현 가능**

### 완전탐색의 핵심
- 문제 크기가 작을 때 확실한 해결 방법
- 복잡한 조건이나 최적화보다는 모든 경우 확인이 우선
- 재귀를 통해 깔끔하게 구현 가능

## 가지치기 (Pruning)
### 개념
- 완전탐색에서 **불필요한 경우를 미리 제거**하여 시간을 단축하는 최적화 기법
- 더 이상 탐색할 필요가 없는 가지(branch)를 잘라내는 것
- 백트래킹과 함께 사용되어 효율성 극대화

### 가지치기의 종류
1. **조건 위반 가지치기**: 문제 조건을 만족하지 않는 경우
2. **최적해 가지치기**: 현재까지의 최적해보다 나빠질 확실한 경우
3. **중복 제거 가지치기**: 이미 확인한 경우와 동일한 경우

### 가지치기 구현 예시
```python
def permutation_with_pruning(i, N, K, current_sum, target):
    # 가지치기: 목표값을 초과하면 더 이상 진행 안 함
    if current_sum > target:
        return
    
    if i == K:
        if current_sum == target:
            print(p)
        return
    
    for j in range(N):
        if used[j] == 0:
            used[j] = 1
            p[i] = arr[j]
            # 현재 합을 다음 재귀로 전달
            permutation_with_pruning(i+1, N, K, current_sum + arr[j], target)
            used[j] = 0
```

### 가지치기 예시: "합이 10인 순열 찾기"
**문제**: [1,2,3,4,5]에서 3개를 뽑아 합이 10인 순열 찾기

**가지치기 없이**:
- (1,2,3), (1,2,4), (1,2,5), (1,3,2), ... 모든 경우 확인
- 5P3 = 60가지 모두 계산

**가지치기 적용**:
- (1,2,?) 단계에서 현재 합 = 3, 남은 최소값 = 3 → 3+3=6 < 10 (계속 진행)
- (1,4,?) 단계에서 현재 합 = 5, 남은 최소값 = 2 → 5+2=7 < 10 (계속 진행)  
- (1,5,?) 단계에서 현재 합 = 6, 남은 최소값 = 2 → 6+2=8 < 10 (계속 진행)
- (4,5,?) 단계에서 현재 합 = 9, 남은 최소값 = 1 → 9+1=10 (계속 진행)
- (5,4,?) 단계에서 현재 합 = 9, 남은 최소값 = 1 → 9+1=10 (계속 진행)
- (5,5,?) 불가능 (중복), (4,4,?) 불가능 (중복)

이런 식으로 **불가능한 경우를 미리 제거**하여 계산량을 대폭 줄일 수 있음

### 가지치기의 효과
- **시간 복잡도 대폭 감소**: 불필요한 계산 제거
- **메모리 효율성**: 깊이 있는 재귀 호출 방지
- **실용성 증가**: 큰 데이터에서도 현실적인 시간 내 해결 가능

### 가지치기 적용 시 주의사항
- **정확성 보장**: 가지치기로 인해 정답을 놓치면 안 됨
- **조건 설정**: 가지치기 조건을 정확히 설정해야 함
- **비용 고려**: 가지치기 판단 자체도 비용이므로 적절히 사용

## 실전 응용 문제
- 주사위 눈 합 문제
- 연속 3장의 트럼프 카드 문제  
- Baby-Jin 문제

이러한 문제들을 통해 재귀호출을 이용한 완전 탐색 구현 방법을 학습