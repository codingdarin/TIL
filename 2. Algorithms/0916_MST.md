# 최소 비용 신장 트리 (MST)

### 신장 트리 (Spanning Tree)
- 그래프의 모든 정점을 포함하는 부분 그래프
- 정점이 n개이면 간선은 정확히 n-1개
- 사이클이 없음 (트리 구조)
- 모든 정점이 연결됨

### 최소 비용 신장 트리 (MST)
- 여러 신장 트리 중에서 **간선들의 가중치 합이 최소**인 트리
- 실생활 예시: 도시 간 전력선 연결, 네트워크 케이블 연결 등 최소 비용으로 모든 지점 연결

### MST를 구하는 두 가지 대표 알고리즘
1. Prim 알고리즘: 정점 중심으로 접근
2. Kruskal 알고리즘: 간선 중심으로 접근

---

## Prim 알고리즘

### 핵심 아이디어
- 정점 하나부터 시작해서 현재 트리에서 갈 수 있는 가장 가까운 정점을 하나씩 추가
- 정점 중심 접근법

### 동작 과정
1. 임의의 시작 정점 선택
2. 현재 MST에서 갈 수 있는 간선 중 가장 가중치가 작은 간선 선택
3. 새로운 정점을 MST에 추가
4. 모든 정점이 포함될 때까지 반복

### 예시
```
정점: A, B, C, D
간선: A-B(1), A-C(4), B-C(2), B-D(5), C-D(3)

1단계: A 선택 → MST = {A}
2단계: A-B(1) 선택 → MST = {A, B}
3단계: B-C(2) 선택 → MST = {A, B, C}
4단계: C-D(3) 선택 → MST = {A, B, C, D}
총 비용: 1 + 2 + 3 = 6
```

### Prim 알고리즘 구현
```python
import heapq

def prim(n, graph):
    visited = [False] * n
    min_heap = [(0, 0)]  # (가중치, 정점)
    mst = []
    total_cost = 0
    
    while min_heap:
        weight, u = heapq.heappop(min_heap)
        
        if visited[u]:
            continue
            
        visited[u] = True
        total_cost += weight
        
        if weight > 0:  # 시작 정점이 아닌 경우
            mst.append((u, weight))
        
        # 인접한 정점들을 힙에 추가
        for v, w in graph[u]:
            if not visited[v]:
                heapq.heappush(min_heap, (w, v))
    
    return mst, total_cost
```

### 시간 복잡도
- **O(E log V)** - 우선순위 큐 사용
- **공간 복잡도**: O(V + E)

---

## Kruskal 알고리즘

### 핵심 아이디어
- 가장 싼 간선부터 하나씩 선택하되, 사이클만 만들지 않기
- 간선 중심 접근법

### 동작 과정
1. 모든 간선을 가중치 기준으로 오름차순 정렬
2. 가중치가 작은 간선부터 하나씩 검사
3. 해당 간선을 추가했을 때 사이클이 생기지 않으면 선택
4. n-1개의 간선을 선택할 때까지 반복

### 사이클 검사
- Union-Find(분리집합) 자료구조 사용
- 두 정점이 이미 같은 집합에 속해있다면 간선 추가 시 사이클 발생

### 예시
```
간선 정렬: A-B(1) < B-C(2) < C-D(3) < A-C(4) < B-D(5)

① A-B(1) 선택 → MST = {A-B(1)}
② B-C(2) 선택 → MST = {A-B(1), B-C(2)}
③ C-D(3) 선택 → MST = {A-B(1), B-C(2), C-D(3)}
④ 완료 (간선 3개) → 총 비용: 6
```

### Kruskal 알고리즘 구현
```python
def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])  # 경로 압축
    return parent[x]

def union(parent, rank, x, y):
    px, py = find(parent, x), find(parent, y)
    
    if px == py:
        return False  # 이미 같은 집합
    
    # Union by rank
    if rank[px] < rank[py]:
        parent[px] = py
    elif rank[px] > rank[py]:
        parent[py] = px
    else:
        parent[py] = px
        rank[px] += 1
    
    return True

def kruskal(n, edges):
    # 간선을 가중치 순으로 정렬
    edges.sort(key=lambda x: x[2])
    
    # Union-Find 초기화
    parent = list(range(n))
    rank = [0] * n
    
    mst = []
    total_cost = 0
    
    for u, v, weight in edges:
        if union(parent, rank, u, v):  # 사이클이 생기지 않으면
            mst.append((u, v, weight))
            total_cost += weight
            
            if len(mst) == n - 1:  # MST 완성
                break
    
    return mst, total_cost
```

### 시간 복잡도
- **O(E log E)** - 간선 정렬 때문
- **공간 복잡도**: O(V)

---

## Prim vs Kruskal 비교

| 구분 | Prim | Kruskal |
|------|------|---------|
| 접근 방식 | 정점 중심 | 간선 중심 |
| 시간 복잡도 | O(E log V) | O(E log E) |
| 적합한 경우 | 밀집 그래프 (간선 많음) | 희소 그래프 (간선 적음) |
| 자료구조 | 우선순위 큐 | Union-Find |
| 알고리즘 특성 | 연결된 트리 확장 | 사이클 없이 간선 추가 |

## 공통점
- 둘 다 **그리디 알고리즘**
- 동일한 MST 결과 생성 (가중치 합 동일)
- 시간 복잡도 모두 O(E log V) 또는 O(E log E)