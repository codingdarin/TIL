# Dijkstra 알고리즘 - 최단 경로

## 최단 경로란?

- 한 정점에서 다른 정점까지 가는 경로 중에서 **가중치의 합이 최소**인 경로
- 물리적 거리가 아니라 **가중치 합** 기준
- 가중치는 시간, 비용, 거리 등 다양할 수 있음

### 예시
```
A에서 D까지 경로들:
경로 1: A → B → D (거리: 2 + 7 = 9)
경로 2: A → C → D (거리: 4 + 3 = 7)  
경로 3: A → B → C → D (거리: 2 + 1 + 3 = 6) ← 최단경로
```

---

## 최단 경로 알고리즘 종류

### 단일 출발점 (Single Source)
- **Dijkstra**: 음수 가중치 없을 때
- **Bellman-Ford**: 음수 가중치 있어도 OK (음수 사이클 감지)

### 모든 쌍 (All Pairs)
- **Floyd-Warshall**: DP 방식, 음수 가중치 OK
- **Johnson's**: 희소 그래프에서 효율적

### 사용 빈도
- **일반적인 경우**: Dijkstra (99%)
- **음수 가중치 있으면**: Bellman-Ford  
- **모든 쌍이 필요하면**: Floyd-Warshall

---

## Dijkstra 알고리즘

### 목적
- **한 정점에서 다른 모든 정점까지의 최단 경로** 찾기

### 핵심 아이디어
- "확정된 정점들에서 갈 수 있는 가장 가까운 정점을 하나씩 확정하기"
- **핵심 가정**: "한 번 확정된 정점의 최단거리는 절대 바뀌지 않는다"

### 사용 조건
- **음수 가중치가 없어야 함**
- 방향 그래프, 무방향 그래프 모두 가능

### 음수 가중치가 안 되는 이유
```
예시: A-B(1), A-C(4), B-C(-3)

Dijkstra 진행:
1. A(0) 확정
2. B(1) 확정 ← 문제 발생 지점
3. B에서 C로: 1 + (-3) = -2

실제 최단: A → B → C = -2
하지만 B가 이미 확정되어 A → C(4)를 먼저 고려했다면 놓칠 수 있음
```

---

## Dijkstra 동작 과정

### 자료구조
1. **distance 배열**: 시작점에서 각 정점까지의 최단거리
2. **visited 배열**: 확정된 정점들 표시  
3. **우선순위 큐**: 다음에 방문할 정점 선택

### 알고리즘 과정
1. 시작 정점의 거리를 0으로, 나머지는 무한대로 초기화
2. 아직 확정되지 않은 정점 중에서 **거리가 가장 짧은 정점** 선택
3. 그 정점을 거쳐서 갈 수 있는 다른 정점들의 거리를 **갱신**
4. 모든 정점이 확정될 때까지 반복

### 상세 예시
```
정점: A(0), B(1), C(2), D(3)
간선: A-B(2), A-C(4), B-C(1), B-D(7), C-D(3)
시작: A

초기화: distance = [0, ∞, ∞, ∞]

1단계: A(0) 처리
- A의 인접 정점 갱신: B(2), C(4)
- distance = [0, 2, 4, ∞]

2단계: B(2) 처리 (최소값)
- B의 인접 정점 갱신: C(3), D(9)
- distance = [0, 2, 3, 9]

3단계: C(3) 처리 (최소값)
- C의 인접 정점 갱신: D(6)
- distance = [0, 2, 3, 6]

4단계: D(6) 처리
- 완료!

최종 결과:
A→A: 0, A→B: 2, A→C: 3, A→D: 6
```

---

## 기본 구현

```python
import heapq

def dijkstra(graph, start):
    n = len(graph)
    distance = [float('inf')] * n
    distance[start] = 0
    heap = [(0, start)]  # (거리, 정점)
    
    while heap:
        current_dist, current = heapq.heappop(heap)
        
        # 이미 처리된 정점이면 스킵
        if current_dist > distance[current]:
            continue
            
        # 인접 정점들 확인
        for neighbor, weight in graph[current]:
            new_dist = current_dist + weight
            
            # 더 짧은 경로 발견시 갱신
            if new_dist < distance[neighbor]:
                distance[neighbor] = new_dist
                heapq.heappush(heap, (new_dist, neighbor))
    
    return distance
```

---

## 경로 추적 구현

```python
def dijkstra_with_path(graph, start):
    n = len(graph)
    distance = [float('inf')] * n
    parent = [-1] * n  # 경로 추적용
    distance[start] = 0
    heap = [(0, start)]
    
    while heap:
        current_dist, current = heapq.heappop(heap)
        
        if current_dist > distance[current]:
            continue
            
        for neighbor, weight in graph[current]:
            new_dist = current_dist + weight
            
            if new_dist < distance[neighbor]:
                distance[neighbor] = new_dist
                parent[neighbor] = current  # 부모 기록
                heapq.heappush(heap, (new_dist, neighbor))
    
    return distance, parent

def get_path(parent, start, end):
    path = []
    current = end
    
    while current != -1:
        path.append(current)
        current = parent[current]
    
    path.reverse()
    return path if path[0] == start else []
```

---

## 그래프 표현 방식

### 무방향 그래프
```python
# A-B 간선이 있으면 양방향으로 저장
def add_edge_undirected(graph, u, v, weight):
    graph[u].append((v, weight))
    graph[v].append((u, weight))  # 양방향 추가
```

### 방향 그래프
```python  
# A→B만 있고 B→A는 없을 수 있음
def add_edge_directed(graph, u, v, weight):
    graph[u].append((v, weight))  # 한 방향만
```

---

## 시간 복잡도

- **시간 복잡도**: O(E log V)
  - 각 간선마다 힙 연산 수행
- **공간 복잡도**: O(V)
  - distance 배열과 힙 저장

## 활용 예시

- GPS 내비게이션 (최단 경로 찾기)
- 네트워크 라우팅 (최적 경로 선택)
- 게임에서 NPC 경로 찾기
- 물류/배송 최적화